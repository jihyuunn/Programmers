### 2-a
- left, right로 인덱싱 조절 
- current에 현재 index의 다음 인덱스를 더한 단어가 dictionary에 있는지 확인   
1. 있으면 다음 index까지 포함한 단어의 숫자를 answer에 append   
2. 없으면 다음 index까지 포함한 단어를 새로 dictionary에 넣고 현재 index까지 단어의 숫자를 answer에 append   
- 마지막 문자를 포함한 단어가 dictionary에 있는지 없는지 구분하여 넣어주기   

### 2-b
- 처음에 이름이 스킬트리여서 트리를 쓰는건가... 삽질   
- check 배열로 만들어서 이전 스킬을 다 배웠는지 확인하려함 -> for문 3중으로 돌려야됨   
- check배열없이 현재 몇번째 skill을 배워야하는지 index만 기억하고 있으면 된다   
1. 현재 스킽트리에서 skill에 포함된 글자가 나오면 index보다 작거나 같아야한다
2. index보다 크면 이전 스킬을 안배웠다는 의미이므로 check=False로 기록   
3. check=True인 경우만 answer += 1   

### 2-c   
- 크게 어렵지 않은 문제였는데 내가 생각 못한 예외 케이스가 있었다 -> 테스트케이스 중요...   
- 첫번째 글자면 uppercase로 하고 first = False로 만들어주고 그 외에 글자면 lowercase로 하고 공백일 시에 first = True로 만들어주기   
- 그런데 중간에 공백이 여러개 있을 때 첫번째 공백에서 True -> 두번째 공백에서 False 가 되어서 세번째에 글자가 나오면 제대로 uppercase로 못바꿔 주었다   
-> 아예 if else끝나고 마지막에 공백인지 체크하고 공백이면 True로 바꿔줌

### 2-d
- 복잡한 문제지만 설명이 순서대로 잘 되어있어서 그대로 코딩하면 된다   
- 사실 전에 한번 풀어본 문제..   

### 2-e
- 프린트 큐 문제   
- 큐 배열에 아무것도 없을 때를 생각해야된다   
```python
queue = [(i,p) for i,p in enumerate(priorities)]
if any(current[1] < q[1] for q in queue)
```
1. enumerate 함수는 인덱스값, 밸류를 리턴하는 함수이다   
2. any 함수는 전달 받은 자료형의 element중 하나라도 True일 경우 True를 리턴한다   

### 2-f
- 가장 큰 수    
- 처음에 그냥 조합으로 풀려고 했음 O(len(numbers)!) => 바로 시간초과남   
- 그래서 큰 수를 먼저 넣어주고 앞자리 숫자가 같은애들만 다시 sort => 시간초과   
- 그냥 정렬을 해주면 되는게 아니고 각 원소들을 string으로 바꿔준 후에 *3을 하면 된다   
-> 그러면 string이기 때문에 각 숫자를 더해야되는 순서대로 sort 가능    

### 2-g
- 기능 개발    
- 완성까지 며칠걸리는지 리스트에 넣고 리스트 숫자 비교   
- 현재 인덱스 숫자 < 다음 인덱스 숫자 면 현재 인덱스를 그냥 배포하면 되는거고 > 인 경우는 다음 인덱스를 배포하려면 현재인덱스가 끝나야 하는 것이므로 temp += 1 하고 반복   

### 2-h
- 전화번호 목록   
- 목록을 길이 순서로 sort한 뒤에 앞에서부터 뒤에 전화번호의 접두어가 되는지 확인한다   
- 목록을 단순 sort하고, zip함수와 startswith함수를 쓰면 더 간결하게 코드작성이 가능하다   
```python
phone_book = [1,2,3,4,5]
print(list(zip(phone_book, phone_book[1:])))
# [(1,2),(2,3),(3,4),(4,5)] -> 똑같은 개수로 묶인다
p1.startswith(p2, startindex, endindex)
# p1 스트링이 p2로 시작하면 True 리턴, 아니면 False 리턴, p1의 범위도 설정가능
```

### 2-i
- 주식 가격   
- 현재 인덱스 다음에 가장 빠르게 나오는 현재 인덱스 보다 작은 숫자를 기록하려고 했음 -> 계속 감소하는 경우를 틀림    
- left, right로 while문 돌리기 -> 시간초과   
- 그냥 단순히 이중 for문 돌려서 숫자 세는 것이 통과됨....   
- 그리고 answer에 append하는게 아니라 [0]*n으로 해놓고 그냥 카운트 +1하면 더 간단하게 짤 수 있다   
- 잘 풀려다보니 너무 어렵게 풀려고 한 것 같다....    

### 2-j
- 더 맵게   
- 처음에 while돌려서 sort하며 풀기 -> 시간초과   
- heaq 사용 -> 통과, 대부분의 풀이도 모두 heapq사용한 것   
### 최대값 최소값을 계속해서 호출해야하는 경우에 heap을 쓰면 효율성이 올라간다   
> ### heap   
> 완전 이진트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다. 부모 노드의 값이 자식 노드보다 항상 큰 이진트리
```python
import heapq
a = [1,3,2,9]
heapq.heapify(a) #원래 리스트를 힙으로 바꿔줌
heapq.heappop(a) #가장 작은 값을 팝
heapq.heappush(a, 10) #a에 10을 넣기
```

### 2-k
- 소수 찾기   
- 숫자 조합을 만들어서 -> 소수인지 아닌지 확인   
- 소수 찾는 에라토스테네스의 체 함수를 만들었는데 초반에 구현이 약간 헷갈렸다   
- 최대 숫자를 착각해서 몇몇 케이스에서 런타임에러가 났음..   
- itertools permutation을 사용하면 바로 조합이 나온다..    
```python
from itertools import permutations
k = '0123'
print(list(map(''.join, permutations(k))))
# ['0123', '0132', '0213', '0231', '0312', '0321', '1023', '1032', '1203', '1230', '1302', '1320', '2013', '2031', '2103', '2130', '2301', '2310', '3012', '3021', '3102', '3120', '3201', '3210']
```
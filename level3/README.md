### 1
- 네트워크   
- 컴퓨터 갯수만큼 check 배열 만들고 얼마나 dfs로 한번에 갈 수 있는 곳 방문하면서 숫자로 기록해두기   
- dfs함수 시작한 만큼 네트워크가 있는 것   

### 2
- 타일 장식물   
- 피보나치 함수 이용하기   

### 3
- 예산
- 상한선의 최대값을 구하는 문제 -> 이분탐색   
- 이미 각 예산이 최대값을 넘지않는 경우를 생각 못해줌   

### 4   
- 가장 먼 노드   
- bfs구현    

### 5   
- 단어변환   
- 어떤 상태에서 어떤 상태로 몇번만에 이동 가능한지 -> bfs/dfs   
- dfs로 풀려고 하다가 잘 안풀려서 bfs로 풀었다   
- 서로 다른 알파벳 개수를 단순히 not in으로 해주니 테스트케이스 3번이 실패했고, 하나하나 비교해주니 통과했다(전체 테케가 작아서 가능했다)   

### 6   
- 이중 우선순위 큐   
- 명령 배열의 길이가 1000000 이어서 그냥 단순히 sort돌려도 풀린다   
- 원래는 heaq를 사용해서 풀어야 함   
```python
import heapq
a = [100,1,2,13,1444,121]
heapq.heapify(a)
heapq.heappop(a) # 가장 작은 수 pop하기
a.remove(max(a)) # 가장 큰 수 제거하기 
heap = []
for num in a:
    heapq.heappush(heap, (-num, num))
heapq.heappop(heap) # 최대값 pop하기
```

### 7   
- 베스트 앨범   
- 일단 장르별로 인덱스 번호랑 재생 숫자 모아놓고, 각 장르안에서 재생 회수로 sort 후에 같은 재생 회수안에서 인덱스 빠른 순으로 정렬하고, 장르 전체 재생 회수로 정렬   
- 고려하지 못한 반례가 너무 많았다(인덱스 순서, 람다 오류)   
```python
a = [[[0, 500], [2, 150], [3, 800]], [[1, 600], [4, 2500]], [[5, 1000]]]
a = sorted(a, key=lambda x: sum(x[1]), reverse=True)
# 이 때 [[5, 1000]] 여기에서 index out of range 오류가 난다 
for j in range(len(a)):
    count[j] = sorted(count[j], key=lambda x:(-x[1], x[0]))
# x의 1번째 인덱스에 있는 요소를 기준으로 reverse해서 정렬하고, 0번째 인덱스를 기준으로 정렬하기
```

### 8    
- 디스크 컨트롤러   
- 다양한 경우의 수를 하나도 고려하지 못했음 처음 채점할 때 2/20개 맞음..   
1. 인풋으로 들어오는 리스트를 시간 순서로 정렬을 해줬다 -> 사실은 처리시간이 작기만 하면 된다. [[0, 3], [2, 1]]이고 현재 시간이 3초일 때 [2, 1]이 먼저 처리가 되어야 한다   
2. 현재 시간이 10초이고, 리스트에 남아있는 req가 [[20, 100], [22, 20]] 일 때는 먼저 들어온 req먼저 처리해줘야한다   
3. 원래 짠 (틀린)코드에서 currentQ가 남아있는 시점에서 jobs를 돌았을 때 totalTime보다 req time이 더 작은애가 없으면 totalTime이 갱신되는 경우가 생길 수 있음    

### 9   
- 입국 심사   
- 모든 사람이 심사받는 최소시간 -> 이분탐색   
- 걸리는 시간의 최소와 최대값을 설정해놓고 반으로 줄여가면서 mid안에 인원 모두 끝낼 수 있는지 확인한다   

### 10    
- JadenCase만들기   
- 시작이 띄어쓰기일 때 런타임에러가 나온다   
```python
a = ' a'
a.split(' ') #['', 'a']
```

### 11   
- 행렬의 곱셈   
- zip을 쓰면 한줄로 풀 수 있다, 그렇지 않으면 나처럼 for문을 3번돌리는 방법이 가장 간단하다...   
```python
X = [[2, 3, 2], [4, 2, 4], [3, 1, 4]]
Y = [[5, 4, 3], [2, 4, 1], [3, 1, 1]]
answer = [[sum(a*b for a, b in zip(X_row,Y_col)) for Y_col in zip(*Y)] for X_row in X]
zip(*Y) # [[5,2,3],[4,4,1],[3,1,1]]로 바뀐다
# X_row = [2,3,2] Y_col = [5,2,3]
zip(X_row, Y_col) # [(2,5), (3,2), (2,3)] 각각을 a,b로 하고 곱해주면 된다   
```